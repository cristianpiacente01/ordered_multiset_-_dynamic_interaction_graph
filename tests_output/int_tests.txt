[Test #0] Inizio unit test per il tipo int

[Test #1] Test 1: ordine crescente con uguaglianza "standard"

[Test #1] 	Metodi fondamentali
[Test #1] 	Inizio costruttore di default
[Test #1] 		Controllo della size uguale a 0... Risultato: 0 OK!
[Test #1] 		Controllo che non sia contenuto nemmeno l'elemento 0... Risultato: true OK!
[Test #1] 		Controllo l'operator== con un altro multiset vuoto dello stesso tipo... Risultato: true OK!
[Test #1] 		Stampo il contenuto vuoto... Risultato: {} OK!
[Test #1] 	Fine costruttore di default

[Test #1] 	Inizio distruttore
[Test #1] 		Creazione oggetto allocato sullo heap e puntatore... OK!
[Test #1] 		Eseguo una delete... OK!
[Test #1] 	Fine distruttore

[Test #1] 	Inizio copy constructor
[Test #1] 		Inizialmente aggiungo qualche elemento al primo multiset creato col ctor di default:
[Test #1] 			Aggiungo l'elemento -1... OK!
[Test #1] 			Aggiungo l'elemento -4... OK!
[Test #1] 			Aggiungo l'elemento 0... OK!
[Test #1] 			Aggiungo l'elemento 0... OK!
[Test #1] 			Aggiungo l'elemento -4... OK!
[Test #1] 			Aggiungo l'elemento -1... OK!
[Test #1] 			Aggiungo l'elemento 4... OK!
[Test #1] 			Aggiungo l'elemento 6... OK!
[Test #1] 			Aggiungo l'elemento -2... OK!
[Test #1] 			Aggiungo l'elemento -10... OK!
[Test #1] 			Aggiungo l'elemento -7... OK!
[Test #1] 			Aggiungo l'elemento 3... OK!
[Test #1] 			Aggiungo l'elemento 42... OK!
[Test #1] 			Aggiungo l'elemento -1... OK!
[Test #1] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #1] 		Stampo il nuovo contenuto del multiset... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>} OK!
[Test #1] 		Ora creo una copia indipendente dei dati utilizzando il cctor... OK!
[Test #1] 		Stampo il multiset appena creato... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>} OK!
[Test #1] 		Controllo con l'operator== i due multiset... Risultato: true OK!
[Test #1] 		Chiamo la clear sul primo multiset e poi lo stampo... Risultato: {} OK!
[Test #1] 		Stampo il secondo multiset verificando l'indipendenza dei dati... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>} OK!
[Test #1] 	Fine copy constructor

[Test #1] 	Inizio operatore di assegnamento
[Test #1] 		Utilizzo l'operator= per assegnare al primo multiset un multiset vuoto creato al volo... OK!
[Test #1] 		Utilizzo l'operator= per assegnare al primo multiset i dati del secondo... OK!
[Test #1] 		Utilizzo l'operator= per assegnare al primo multiset se' stesso (auto-assegnamento)... OK!
[Test #1] 		Stampo il primo multiset... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>} OK!
[Test #1] 		Rimuovo l'unica occorrenza dell'elemento 6 dal secondo multiset per poi verificare l'indipendenza... OK!
[Test #1] 		Stampo il primo multiset... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>} OK!
[Test #1] 		Stampo il secondo multiset... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>} OK!
[Test #1] 		Rimuovo un'occorrenza dell'elemento -4 dal primo multiset per poi verificare l'indipendenza... OK!
[Test #1] 		Stampo il primo multiset... Risultato: {<-10, 1>, <-7, 1>, <-4, 1>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>} OK!
[Test #1] 		Stampo il secondo multiset... Risultato: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>} OK!
[Test #1] 	Fine operatore di assegnamento
[Test #1] 	Fine metodi fondamentali

[Test #1] 	Inizio test interfaccia pubblica
[Test #1] 	Inizio costruttore che prende una coppia di iteratori
[Test #1] 		Gli elementi che saranno aggiunti sono -1 0 -4 4 -2 -7 42 
[Test #1] 		Creazione multiset usando due iteratori... Risultato: {<-7, 1>, <-4, 1>, <-2, 1>, <-1, 1>, <0, 1>, <4, 1>, <42, 1>} OK!
[Test #1] 		Creazione multiset usando due iteratori uguali, quindi che risultera' vuoto... Risultato: {} OK!
[Test #1] 	Fine costruttore che prende una coppia di iteratori

[Test #1] 	Inizio metodo clear
[Test #1] 		Utilizzo la clear su un multiset non vuoto, ossia quello costruito con due iteratori
[Test #1] 		Prima della clear: {<-7, 1>, <-4, 1>, <-2, 1>, <-1, 1>, <0, 1>, <4, 1>, <42, 1>}
[Test #1] 		Dopo la clear: {} OK!
[Test #1] 		Utilizzo la clear su un multiset vuoto, ossia quello costruito con due iteratori uguali
[Test #1] 		Prima della clear: {}
[Test #1] 		Dopo la clear: {} OK!
[Test #1] 	Fine metodo clear

[Test #1] 	Inizio metodo swap
[Test #1] 		Riutilizzo due multiset creati in precedenza qui sotto stampati:
[Test #1] 		Primo multiset: {<-10, 1>, <-7, 1>, <-4, 1>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>}
[Test #1] 		Secondo multiset: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>}
[Test #1] 		Chiamo la swap... OK!
[Test #1] 		Controllo che i due contenuti siano stati scambiati... OK!
[Test #1] 		Stampo i due multiset dopo la swap qui sotto:
[Test #1] 		Primo multiset: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>}
[Test #1] 		Secondo multiset: {<-10, 1>, <-7, 1>, <-4, 1>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <6, 1>, <42, 1>}
[Test #1] 		Ora scambio il primo multiset con un multiset vuoto creato in precedenza... OK!
[Test #1] 		Stampo qui sotto i due multiset:
[Test #1] 		Multiset che era vuoto: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>}
[Test #1] 		Multiset che era riempito: {}
[Test #1] 		Li riporto allo stato originale con un'altra swap... OK!
[Test #1] 		Multiset di nuovo vuoto: {}
[Test #1] 		Multiset di nuovo riempito: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>}
[Test #1] 		Infine scambio due multiset vuoti tra di loro e li stampo... {} {} OK!
[Test #1] 	Fine metodo swap

[Test #1] 	Inizio metodo size
[Test #1] 		Chiamo la size su un multiset vuoto, mi aspetto 0... Risultato: 0 OK!
[Test #1] 		Chiamo la size sul multiset utilizzato in precedenza che stampo qui sotto:
[Test #1] 		Multiset: {<-10, 1>, <-7, 1>, <-4, 2>, <-2, 1>, <-1, 3>, <0, 2>, <3, 1>, <4, 1>, <42, 1>}
[Test #1] 		Mi aspetto 13... Risultato: 13 OK!
[Test #1] 		Aggiungo l'elemento 31 e verifico che la size venga incrementata, mi aspetto 14... Risultato: 14 OK!
[Test #1] 		Rimuovo l'elemento appena aggiunto e verifico che la size venga decrementata, mi aspetto 13... Risultato: 13 OK!
[Test #1] 	Fine metodo size

[Test #1] 	Inizio metodo add
[Test #1] 		Utilizzo un multiset vuoto: {}
[Test #1] 		Aggiungo 30 volte l'elemento 0... OK!
[Test #1] 		Verifico la correttezza del contenuto, mi aspetto {<0, 30>}... Risultato: {<0, 30>} OK!
[Test #1] 		Aggiungo altri elementi:
[Test #1] 			Aggiungo l'elemento -4... OK!
[Test #1] 			Aggiungo l'elemento 0... OK!
[Test #1] 			Aggiungo l'elemento -1... OK!
[Test #1] 			Aggiungo l'elemento 6... OK!
[Test #1] 			Aggiungo l'elemento -10... OK!
[Test #1] 			Aggiungo l'elemento 3... OK!
[Test #1] 			Aggiungo l'elemento -1... OK!
[Test #1] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #1] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #1] 		{<-10, 1>, <-4, 1>, <-1, 2>, <0, 31>, <3, 1>, <6, 1>} OK!
[Test #1] 	Fine metodo add

[Test #1] 	Inizio metodo remove
[Test #1] 		Utilizzo lo stesso multiset di prima, rimuovo 30 occorrenze di 0... OK!
[Test #1] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #1] 		{<-10, 1>, <-4, 1>, <-1, 2>, <0, 1>, <3, 1>, <6, 1>} OK!
[Test #1] 		Verifico che ci sia una sola occorrenza di 0... Risultato: true OK!
[Test #1] 		Elimino l'ultima occorrenza di 0... OK!
[Test #1] 		Stampo il nuovo contenuto qui sotto:
[Test #1] 		{<-10, 1>, <-4, 1>, <-1, 2>, <3, 1>, <6, 1>} OK!
[Test #1] 		(Mi aspetto l'eccezione custom) Provo ad eliminare l'elemento 31 non presente:
[Test #1] 		Eccezione custom catturata: Impossibile rimuovere un elemento non presente nel multiset ordinato.
[Test #1] 	Fine metodo remove

[Test #1] 	Inizio metodo multiplicity
[Test #1] 		Uso l'ultimo multiset utilizzato, controllo che per ogni elemento il metodo multiplicity restituisca il numero di occorrenze corretto:
[Test #1] 			Molteplicita' dell'elemento -10 aspettata 1, ho 1 OK!
[Test #1] 			Molteplicita' dell'elemento -4 aspettata 1, ho 1 OK!
[Test #1] 			Molteplicita' dell'elemento -1 aspettata 2, ho 2 OK!
[Test #1] 			Molteplicita' dell'elemento 3 aspettata 1, ho 1 OK!
[Test #1] 			Molteplicita' dell'elemento 6 aspettata 1, ho 1 OK!
[Test #1] 		Molteplicita' dell'elemento 0 non presente... Risultato: 0 OK!
[Test #1] 	Fine metodo multiplicity

[Test #1] 	Inizio operator==
[Test #1] 		A partire dall'ultimo multiset utilizzato creo un altro multiset ma con policy di ordinamento diversa:
[Test #1] 			Stampo il multiset che vado ad utilizzare:
[Test #1] 			{<-10, 1>, <-4, 1>, <-1, 2>, <3, 1>, <6, 1>} OK!
[Test #1] 			Creo un nuovo multiset con ordinamento diverso, utilizzando il costruttore che prende due iteratori... OK!
[Test #1] 		Nuovo multiset con ordinamento diverso creato, lo stampo qui sotto:
[Test #1] 		{<6, 1>, <3, 1>, <-1, 2>, <-4, 1>, <-10, 1>}
[Test #1] 		Utilizzo l'operator== tra i due multiset ordinati in modo diverso... Risultato: true OK!
[Test #1] 		Aggiungo l'elemento 0 al nuovo multiset e verifico che siano diversi... OK!
[Test #1] 		Stampo il nuovo multiset qui sotto:
[Test #1] 		{<6, 1>, <3, 1>, <0, 1>, <-1, 2>, <-4, 1>, <-10, 1>}
[Test #1] 		Svuoto quest'ultimo con la clear... OK!
[Test #1] 		Stampo il multiset... Risultato: {} OK!
[Test #1] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento uguale... Risultato: true OK!
[Test #1] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento diverso... Risultato: true OK!
[Test #1] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento uguale... Risultato: true OK!
[Test #1] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento diverso... Risultato: true OK!
[Test #1] 	Fine operator==

[Test #1] 	Inizio metodo contains
[Test #1] 		Creo un nuovo multiset con i seguenti valori: 1 2 1 1 1 9 1 7 10 10 
[Test #1] 		Stampo il nuovo contenuto qui sotto:
[Test #1] 		{<1, 5>, <2, 1>, <7, 1>, <9, 1>, <10, 2>} OK!
[Test #1] 		Controllo che la contains dia true per ogni elemento distinto del multiset:
[Test #1] 			Contains dell'elemento 1... Risultato: true OK!
[Test #1] 			Contains dell'elemento 2... Risultato: true OK!
[Test #1] 			Contains dell'elemento 7... Risultato: true OK!
[Test #1] 			Contains dell'elemento 9... Risultato: true OK!
[Test #1] 			Contains dell'elemento 10... Risultato: true OK!
[Test #1] 		Controllo che la contains dia false per un elemento non contenuto:
[Test #1] 			Contains dell'elemento 31... Risultato: false OK!
[Test #1] 	Fine metodo contains

[Test #1] 	Inizio stampa con iteratori
[Test #1] 		Uso l'ultimo multiset utilizzato, stampo gli elementi in ordine del multiset ordinato tramite gli iteratori:
[Test #1] 		1 1 1 1 1 2 7 9 10 10  OK!
[Test #1] 		Ora di nuovo ma stampo partendo dalla fine, per utilizzare il decremento nell'iteratore bidirectional:
[Test #1] 		10 10 9 7 2 1 1 1 1 1  OK!
[Test #1] 		Controllo che gli elementi restituiti dall'iteratore costituiscono una permutazione degli elementi inseriti in precedenza... Risultato: true OK!
[Test #1] 		Stampo con gli iteratori un multiset vuoto:
[Test #1] 		 OK!
[Test #1] 	Fine stampa con iteratori

[Test #1] 	Fine interfaccia pubblica

[Test #1] 	Inizio const correctness
[Test #1] 	Metodi utilizzabili (da parte dell'utente o meno, come il distruttore) su un ordered_multiset costante:
[Test #1] 		Ctor di default... OK!
[Test #1] 		Costruttore che prende una coppia di iteratori... OK!
[Test #1] 		Distruttore... OK!
[Test #1] 		Copy constructor... OK!
[Test #1] 		Size... OK!
[Test #1] 		Multiplicity... OK!
[Test #1] 		Operatore di uguaglianza operator==... OK!
[Test #1] 		Contains... OK!
[Test #1] 		Begin... OK!
[Test #1] 		End... OK!
[Test #1] 		Operatore di stream operator<<... {<1, 5>, <2, 1>, <7, 1>, <9, 1>, <10, 2>} OK!
[Test #1] 	Fine metodi utilizzabili per multiset costanti

[Test #1] 	I metodi non utilizzabili dell'interfaccia pubblica per multiset costanti sono:
[Test #1] 	operator=, clear, swap, add, remove.
[Test #1] 	Fine const correctness

[Test #1] Fine test 1

[Test #2] Test 2: ordine decrescente con uguaglianza "standard"

[Test #2] 	Metodi fondamentali
[Test #2] 	Inizio costruttore di default
[Test #2] 		Controllo della size uguale a 0... Risultato: 0 OK!
[Test #2] 		Controllo che non sia contenuto nemmeno l'elemento 0... Risultato: true OK!
[Test #2] 		Controllo l'operator== con un altro multiset vuoto dello stesso tipo... Risultato: true OK!
[Test #2] 		Stampo il contenuto vuoto... Risultato: {} OK!
[Test #2] 	Fine costruttore di default

[Test #2] 	Inizio distruttore
[Test #2] 		Creazione oggetto allocato sullo heap e puntatore... OK!
[Test #2] 		Eseguo una delete... OK!
[Test #2] 	Fine distruttore

[Test #2] 	Inizio copy constructor
[Test #2] 		Inizialmente aggiungo qualche elemento al primo multiset creato col ctor di default:
[Test #2] 			Aggiungo l'elemento 4... OK!
[Test #2] 			Aggiungo l'elemento 2... OK!
[Test #2] 			Aggiungo l'elemento 8... OK!
[Test #2] 			Aggiungo l'elemento 8... OK!
[Test #2] 			Aggiungo l'elemento 2... OK!
[Test #2] 			Aggiungo l'elemento 9... OK!
[Test #2] 			Aggiungo l'elemento 20... OK!
[Test #2] 			Aggiungo l'elemento -1... OK!
[Test #2] 			Aggiungo l'elemento -4... OK!
[Test #2] 			Aggiungo l'elemento -4... OK!
[Test #2] 			Aggiungo l'elemento -5... OK!
[Test #2] 			Aggiungo l'elemento 10... OK!
[Test #2] 			Aggiungo l'elemento 50... OK!
[Test #2] 			Aggiungo l'elemento 51... OK!
[Test #2] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #2] 		Stampo il nuovo contenuto del multiset... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>} OK!
[Test #2] 		Ora creo una copia indipendente dei dati utilizzando il cctor... OK!
[Test #2] 		Stampo il multiset appena creato... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>} OK!
[Test #2] 		Controllo con l'operator== i due multiset... Risultato: true OK!
[Test #2] 		Chiamo la clear sul primo multiset e poi lo stampo... Risultato: {} OK!
[Test #2] 		Stampo il secondo multiset verificando l'indipendenza dei dati... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>} OK!
[Test #2] 	Fine copy constructor

[Test #2] 	Inizio operatore di assegnamento
[Test #2] 		Utilizzo l'operator= per assegnare al primo multiset un multiset vuoto creato al volo... OK!
[Test #2] 		Utilizzo l'operator= per assegnare al primo multiset i dati del secondo... OK!
[Test #2] 		Utilizzo l'operator= per assegnare al primo multiset se' stesso (auto-assegnamento)... OK!
[Test #2] 		Stampo il primo multiset... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>} OK!
[Test #2] 		Rimuovo l'unica occorrenza dell'elemento -1 dal secondo multiset per poi verificare l'indipendenza... OK!
[Test #2] 		Stampo il primo multiset... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>} OK!
[Test #2] 		Stampo il secondo multiset... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>} OK!
[Test #2] 		Rimuovo un'occorrenza dell'elemento 10 dal primo multiset per poi verificare l'indipendenza... OK!
[Test #2] 		Stampo il primo multiset... Risultato: {<51, 1>, <50, 1>, <20, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>} OK!
[Test #2] 		Stampo il secondo multiset... Risultato: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>} OK!
[Test #2] 	Fine operatore di assegnamento
[Test #2] 	Fine metodi fondamentali

[Test #2] 	Inizio test interfaccia pubblica
[Test #2] 	Inizio costruttore che prende una coppia di iteratori
[Test #2] 		Gli elementi che saranno aggiunti sono 4 8 2 20 -4 -5 50 
[Test #2] 		Creazione multiset usando due iteratori... Risultato: {<50, 1>, <20, 1>, <8, 1>, <4, 1>, <2, 1>, <-4, 1>, <-5, 1>} OK!
[Test #2] 		Creazione multiset usando due iteratori uguali, quindi che risultera' vuoto... Risultato: {} OK!
[Test #2] 	Fine costruttore che prende una coppia di iteratori

[Test #2] 	Inizio metodo clear
[Test #2] 		Utilizzo la clear su un multiset non vuoto, ossia quello costruito con due iteratori
[Test #2] 		Prima della clear: {<50, 1>, <20, 1>, <8, 1>, <4, 1>, <2, 1>, <-4, 1>, <-5, 1>}
[Test #2] 		Dopo la clear: {} OK!
[Test #2] 		Utilizzo la clear su un multiset vuoto, ossia quello costruito con due iteratori uguali
[Test #2] 		Prima della clear: {}
[Test #2] 		Dopo la clear: {} OK!
[Test #2] 	Fine metodo clear

[Test #2] 	Inizio metodo swap
[Test #2] 		Riutilizzo due multiset creati in precedenza qui sotto stampati:
[Test #2] 		Primo multiset: {<51, 1>, <50, 1>, <20, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>}
[Test #2] 		Secondo multiset: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>}
[Test #2] 		Chiamo la swap... OK!
[Test #2] 		Controllo che i due contenuti siano stati scambiati... OK!
[Test #2] 		Stampo i due multiset dopo la swap qui sotto:
[Test #2] 		Primo multiset: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>}
[Test #2] 		Secondo multiset: {<51, 1>, <50, 1>, <20, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-1, 1>, <-4, 2>, <-5, 1>}
[Test #2] 		Ora scambio il primo multiset con un multiset vuoto creato in precedenza... OK!
[Test #2] 		Stampo qui sotto i due multiset:
[Test #2] 		Multiset che era vuoto: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>}
[Test #2] 		Multiset che era riempito: {}
[Test #2] 		Li riporto allo stato originale con un'altra swap... OK!
[Test #2] 		Multiset di nuovo vuoto: {}
[Test #2] 		Multiset di nuovo riempito: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>}
[Test #2] 		Infine scambio due multiset vuoti tra di loro e li stampo... {} {} OK!
[Test #2] 	Fine metodo swap

[Test #2] 	Inizio metodo size
[Test #2] 		Chiamo la size su un multiset vuoto, mi aspetto 0... Risultato: 0 OK!
[Test #2] 		Chiamo la size sul multiset utilizzato in precedenza che stampo qui sotto:
[Test #2] 		Multiset: {<51, 1>, <50, 1>, <20, 1>, <10, 1>, <9, 1>, <8, 2>, <4, 1>, <2, 2>, <-4, 2>, <-5, 1>}
[Test #2] 		Mi aspetto 13... Risultato: 13 OK!
[Test #2] 		Aggiungo l'elemento 60 e verifico che la size venga incrementata, mi aspetto 14... Risultato: 14 OK!
[Test #2] 		Rimuovo l'elemento appena aggiunto e verifico che la size venga decrementata, mi aspetto 13... Risultato: 13 OK!
[Test #2] 	Fine metodo size

[Test #2] 	Inizio metodo add
[Test #2] 		Utilizzo un multiset vuoto: {}
[Test #2] 		Aggiungo 28 volte l'elemento 0... OK!
[Test #2] 		Verifico la correttezza del contenuto, mi aspetto {<0, 28>}... Risultato: {<0, 28>} OK!
[Test #2] 		Aggiungo altri elementi:
[Test #2] 			Aggiungo l'elemento 2... OK!
[Test #2] 			Aggiungo l'elemento 8... OK!
[Test #2] 			Aggiungo l'elemento 9... OK!
[Test #2] 			Aggiungo l'elemento -1... OK!
[Test #2] 			Aggiungo l'elemento -4... OK!
[Test #2] 			Aggiungo l'elemento 10... OK!
[Test #2] 			Aggiungo l'elemento 51... OK!
[Test #2] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #2] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #2] 		{<51, 1>, <10, 1>, <9, 1>, <8, 1>, <2, 1>, <0, 28>, <-1, 1>, <-4, 1>} OK!
[Test #2] 	Fine metodo add

[Test #2] 	Inizio metodo remove
[Test #2] 		Utilizzo lo stesso multiset di prima, rimuovo 27 occorrenze di 0... OK!
[Test #2] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #2] 		{<51, 1>, <10, 1>, <9, 1>, <8, 1>, <2, 1>, <0, 1>, <-1, 1>, <-4, 1>} OK!
[Test #2] 		Verifico che ci sia una sola occorrenza di 0... Risultato: true OK!
[Test #2] 		Elimino l'ultima occorrenza di 0... OK!
[Test #2] 		Stampo il nuovo contenuto qui sotto:
[Test #2] 		{<51, 1>, <10, 1>, <9, 1>, <8, 1>, <2, 1>, <-1, 1>, <-4, 1>} OK!
[Test #2] 		(Mi aspetto l'eccezione custom) Provo ad eliminare l'elemento 60 non presente:
[Test #2] 		Eccezione custom catturata: Impossibile rimuovere un elemento non presente nel multiset ordinato.
[Test #2] 	Fine metodo remove

[Test #2] 	Inizio metodo multiplicity
[Test #2] 		Uso l'ultimo multiset utilizzato, controllo che per ogni elemento il metodo multiplicity restituisca il numero di occorrenze corretto:
[Test #2] 			Molteplicita' dell'elemento 51 aspettata 1, ho 1 OK!
[Test #2] 			Molteplicita' dell'elemento 10 aspettata 1, ho 1 OK!
[Test #2] 			Molteplicita' dell'elemento 9 aspettata 1, ho 1 OK!
[Test #2] 			Molteplicita' dell'elemento 8 aspettata 1, ho 1 OK!
[Test #2] 			Molteplicita' dell'elemento 2 aspettata 1, ho 1 OK!
[Test #2] 			Molteplicita' dell'elemento -1 aspettata 1, ho 1 OK!
[Test #2] 			Molteplicita' dell'elemento -4 aspettata 1, ho 1 OK!
[Test #2] 		Molteplicita' dell'elemento 0 non presente... Risultato: 0 OK!
[Test #2] 	Fine metodo multiplicity

[Test #2] 	Inizio operator==
[Test #2] 		A partire dall'ultimo multiset utilizzato creo un altro multiset ma con policy di ordinamento diversa:
[Test #2] 			Stampo il multiset che vado ad utilizzare:
[Test #2] 			{<51, 1>, <10, 1>, <9, 1>, <8, 1>, <2, 1>, <-1, 1>, <-4, 1>} OK!
[Test #2] 			Creo un nuovo multiset con ordinamento diverso, utilizzando il costruttore che prende due iteratori... OK!
[Test #2] 		Nuovo multiset con ordinamento diverso creato, lo stampo qui sotto:
[Test #2] 		{<-4, 1>, <-1, 1>, <2, 1>, <8, 1>, <9, 1>, <10, 1>, <51, 1>}
[Test #2] 		Utilizzo l'operator== tra i due multiset ordinati in modo diverso... Risultato: true OK!
[Test #2] 		Aggiungo l'elemento 0 al nuovo multiset e verifico che siano diversi... OK!
[Test #2] 		Stampo il nuovo multiset qui sotto:
[Test #2] 		{<-4, 1>, <-1, 1>, <0, 1>, <2, 1>, <8, 1>, <9, 1>, <10, 1>, <51, 1>}
[Test #2] 		Svuoto quest'ultimo con la clear... OK!
[Test #2] 		Stampo il multiset... Risultato: {} OK!
[Test #2] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento uguale... Risultato: true OK!
[Test #2] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento diverso... Risultato: true OK!
[Test #2] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento uguale... Risultato: true OK!
[Test #2] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento diverso... Risultato: true OK!
[Test #2] 	Fine operator==

[Test #2] 	Inizio metodo contains
[Test #2] 		Creo un nuovo multiset con i seguenti valori: 39 2 -2 -2 -5 -5 40 30 30 20 7 1 9 41 -75 
[Test #2] 		Stampo il nuovo contenuto qui sotto:
[Test #2] 		{<41, 1>, <40, 1>, <39, 1>, <30, 2>, <20, 1>, <9, 1>, <7, 1>, <2, 1>, <1, 1>, <-2, 2>, <-5, 2>, <-75, 1>} OK!
[Test #2] 		Controllo che la contains dia true per ogni elemento distinto del multiset:
[Test #2] 			Contains dell'elemento 41... Risultato: true OK!
[Test #2] 			Contains dell'elemento 40... Risultato: true OK!
[Test #2] 			Contains dell'elemento 39... Risultato: true OK!
[Test #2] 			Contains dell'elemento 30... Risultato: true OK!
[Test #2] 			Contains dell'elemento 20... Risultato: true OK!
[Test #2] 			Contains dell'elemento 9... Risultato: true OK!
[Test #2] 			Contains dell'elemento 7... Risultato: true OK!
[Test #2] 			Contains dell'elemento 2... Risultato: true OK!
[Test #2] 			Contains dell'elemento 1... Risultato: true OK!
[Test #2] 			Contains dell'elemento -2... Risultato: true OK!
[Test #2] 			Contains dell'elemento -5... Risultato: true OK!
[Test #2] 			Contains dell'elemento -75... Risultato: true OK!
[Test #2] 		Controllo che la contains dia false per un elemento non contenuto:
[Test #2] 			Contains dell'elemento 60... Risultato: false OK!
[Test #2] 	Fine metodo contains

[Test #2] 	Inizio stampa con iteratori
[Test #2] 		Uso l'ultimo multiset utilizzato, stampo gli elementi in ordine del multiset ordinato tramite gli iteratori:
[Test #2] 		41 40 39 30 30 20 9 7 2 1 -2 -2 -5 -5 -75  OK!
[Test #2] 		Ora di nuovo ma stampo partendo dalla fine, per utilizzare il decremento nell'iteratore bidirectional:
[Test #2] 		-75 -5 -5 -2 -2 1 2 7 9 20 30 30 39 40 41  OK!
[Test #2] 		Controllo che gli elementi restituiti dall'iteratore costituiscono una permutazione degli elementi inseriti in precedenza... Risultato: true OK!
[Test #2] 		Stampo con gli iteratori un multiset vuoto:
[Test #2] 		 OK!
[Test #2] 	Fine stampa con iteratori

[Test #2] 	Fine interfaccia pubblica

[Test #2] 	Inizio const correctness
[Test #2] 	Metodi utilizzabili (da parte dell'utente o meno, come il distruttore) su un ordered_multiset costante:
[Test #2] 		Ctor di default... OK!
[Test #2] 		Costruttore che prende una coppia di iteratori... OK!
[Test #2] 		Distruttore... OK!
[Test #2] 		Copy constructor... OK!
[Test #2] 		Size... OK!
[Test #2] 		Multiplicity... OK!
[Test #2] 		Operatore di uguaglianza operator==... OK!
[Test #2] 		Contains... OK!
[Test #2] 		Begin... OK!
[Test #2] 		End... OK!
[Test #2] 		Operatore di stream operator<<... {<41, 1>, <40, 1>, <39, 1>, <30, 2>, <20, 1>, <9, 1>, <7, 1>, <2, 1>, <1, 1>, <-2, 2>, <-5, 2>, <-75, 1>} OK!
[Test #2] 	Fine metodi utilizzabili per multiset costanti

[Test #2] 	I metodi non utilizzabili dell'interfaccia pubblica per multiset costanti sono:
[Test #2] 	operator=, clear, swap, add, remove.
[Test #2] 	Fine const correctness

[Test #2] Fine test 2

[Test #3] Test 3: ordine crescente in Z_4

[Test #3] 	Metodi fondamentali
[Test #3] 	Inizio costruttore di default
[Test #3] 		Controllo della size uguale a 0... Risultato: 0 OK!
[Test #3] 		Controllo che non sia contenuto nemmeno l'elemento 0... Risultato: true OK!
[Test #3] 		Controllo l'operator== con un altro multiset vuoto dello stesso tipo... Risultato: true OK!
[Test #3] 		Stampo il contenuto vuoto... Risultato: {} OK!
[Test #3] 	Fine costruttore di default

[Test #3] 	Inizio distruttore
[Test #3] 		Creazione oggetto allocato sullo heap e puntatore... OK!
[Test #3] 		Eseguo una delete... OK!
[Test #3] 	Fine distruttore

[Test #3] 	Inizio copy constructor
[Test #3] 		Inizialmente aggiungo qualche elemento al primo multiset creato col ctor di default:
[Test #3] 			Aggiungo l'elemento 1... OK!
[Test #3] 			Aggiungo l'elemento 2... OK!
[Test #3] 			Aggiungo l'elemento 3... OK!
[Test #3] 			Aggiungo l'elemento 5... OK!
[Test #3] 			Aggiungo l'elemento 2... OK!
[Test #3] 			Aggiungo l'elemento 9... OK!
[Test #3] 			Aggiungo l'elemento -3... OK!
[Test #3] 			Aggiungo l'elemento -7... OK!
[Test #3] 			Aggiungo l'elemento -2... OK!
[Test #3] 			Aggiungo l'elemento 9... OK!
[Test #3] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #3] 		Stampo il nuovo contenuto del multiset... Risultato: {<1, 6>, <2, 3>, <3, 1>} OK!
[Test #3] 		Ora creo una copia indipendente dei dati utilizzando il cctor... OK!
[Test #3] 		Stampo il multiset appena creato... Risultato: {<1, 6>, <2, 3>, <3, 1>} OK!
[Test #3] 		Controllo con l'operator== i due multiset... Risultato: true OK!
[Test #3] 		Chiamo la clear sul primo multiset e poi lo stampo... Risultato: {} OK!
[Test #3] 		Stampo il secondo multiset verificando l'indipendenza dei dati... Risultato: {<1, 6>, <2, 3>, <3, 1>} OK!
[Test #3] 	Fine copy constructor

[Test #3] 	Inizio operatore di assegnamento
[Test #3] 		Utilizzo l'operator= per assegnare al primo multiset un multiset vuoto creato al volo... OK!
[Test #3] 		Utilizzo l'operator= per assegnare al primo multiset i dati del secondo... OK!
[Test #3] 		Utilizzo l'operator= per assegnare al primo multiset se' stesso (auto-assegnamento)... OK!
[Test #3] 		Stampo il primo multiset... Risultato: {<1, 6>, <2, 3>, <3, 1>} OK!
[Test #3] 		Rimuovo l'unica occorrenza dell'elemento 3 dal secondo multiset per poi verificare l'indipendenza... OK!
[Test #3] 		Stampo il primo multiset... Risultato: {<1, 6>, <2, 3>, <3, 1>} OK!
[Test #3] 		Stampo il secondo multiset... Risultato: {<1, 6>, <2, 3>} OK!
[Test #3] 		Rimuovo un'occorrenza dell'elemento 1 dal primo multiset per poi verificare l'indipendenza... OK!
[Test #3] 		Stampo il primo multiset... Risultato: {<1, 5>, <2, 3>, <3, 1>} OK!
[Test #3] 		Stampo il secondo multiset... Risultato: {<1, 6>, <2, 3>} OK!
[Test #3] 	Fine operatore di assegnamento
[Test #3] 	Fine metodi fondamentali

[Test #3] 	Inizio test interfaccia pubblica
[Test #3] 	Inizio costruttore che prende una coppia di iteratori
[Test #3] 		Gli elementi che saranno aggiunti sono 1 3 2 -3 -2 
[Test #3] 		Creazione multiset usando due iteratori... Risultato: {<1, 2>, <2, 2>, <3, 1>} OK!
[Test #3] 		Creazione multiset usando due iteratori uguali, quindi che risultera' vuoto... Risultato: {} OK!
[Test #3] 	Fine costruttore che prende una coppia di iteratori

[Test #3] 	Inizio metodo clear
[Test #3] 		Utilizzo la clear su un multiset non vuoto, ossia quello costruito con due iteratori
[Test #3] 		Prima della clear: {<1, 2>, <2, 2>, <3, 1>}
[Test #3] 		Dopo la clear: {} OK!
[Test #3] 		Utilizzo la clear su un multiset vuoto, ossia quello costruito con due iteratori uguali
[Test #3] 		Prima della clear: {}
[Test #3] 		Dopo la clear: {} OK!
[Test #3] 	Fine metodo clear

[Test #3] 	Inizio metodo swap
[Test #3] 		Riutilizzo due multiset creati in precedenza qui sotto stampati:
[Test #3] 		Primo multiset: {<1, 5>, <2, 3>, <3, 1>}
[Test #3] 		Secondo multiset: {<1, 6>, <2, 3>}
[Test #3] 		Chiamo la swap... OK!
[Test #3] 		Controllo che i due contenuti siano stati scambiati... OK!
[Test #3] 		Stampo i due multiset dopo la swap qui sotto:
[Test #3] 		Primo multiset: {<1, 6>, <2, 3>}
[Test #3] 		Secondo multiset: {<1, 5>, <2, 3>, <3, 1>}
[Test #3] 		Ora scambio il primo multiset con un multiset vuoto creato in precedenza... OK!
[Test #3] 		Stampo qui sotto i due multiset:
[Test #3] 		Multiset che era vuoto: {<1, 6>, <2, 3>}
[Test #3] 		Multiset che era riempito: {}
[Test #3] 		Li riporto allo stato originale con un'altra swap... OK!
[Test #3] 		Multiset di nuovo vuoto: {}
[Test #3] 		Multiset di nuovo riempito: {<1, 6>, <2, 3>}
[Test #3] 		Infine scambio due multiset vuoti tra di loro e li stampo... {} {} OK!
[Test #3] 	Fine metodo swap

[Test #3] 	Inizio metodo size
[Test #3] 		Chiamo la size su un multiset vuoto, mi aspetto 0... Risultato: 0 OK!
[Test #3] 		Chiamo la size sul multiset utilizzato in precedenza che stampo qui sotto:
[Test #3] 		Multiset: {<1, 6>, <2, 3>}
[Test #3] 		Mi aspetto 9... Risultato: 9 OK!
[Test #3] 		Aggiungo l'elemento 0 e verifico che la size venga incrementata, mi aspetto 10... Risultato: 10 OK!
[Test #3] 		Rimuovo l'elemento appena aggiunto e verifico che la size venga decrementata, mi aspetto 9... Risultato: 9 OK!
[Test #3] 	Fine metodo size

[Test #3] 	Inizio metodo add
[Test #3] 		Utilizzo un multiset vuoto: {}
[Test #3] 		Aggiungo 5 volte l'elemento 0... OK!
[Test #3] 		Verifico la correttezza del contenuto, mi aspetto {<0, 5>}... Risultato: {<0, 5>} OK!
[Test #3] 		Aggiungo altri elementi:
[Test #3] 			Aggiungo l'elemento 2... OK!
[Test #3] 			Aggiungo l'elemento 5... OK!
[Test #3] 			Aggiungo l'elemento 9... OK!
[Test #3] 			Aggiungo l'elemento -7... OK!
[Test #3] 			Aggiungo l'elemento 9... OK!
[Test #3] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #3] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #3] 		{<0, 5>, <5, 4>, <2, 1>} OK!
[Test #3] 	Fine metodo add

[Test #3] 	Inizio metodo remove
[Test #3] 		Utilizzo lo stesso multiset di prima, rimuovo 4 occorrenze di 0... OK!
[Test #3] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #3] 		{<0, 1>, <5, 4>, <2, 1>} OK!
[Test #3] 		Verifico che ci sia una sola occorrenza di 0... Risultato: true OK!
[Test #3] 		Elimino l'ultima occorrenza di 0... OK!
[Test #3] 		Stampo il nuovo contenuto qui sotto:
[Test #3] 		{<5, 4>, <2, 1>} OK!
[Test #3] 		(Mi aspetto l'eccezione custom) Provo ad eliminare l'elemento 0 non presente:
[Test #3] 		Eccezione custom catturata: Impossibile rimuovere un elemento non presente nel multiset ordinato.
[Test #3] 	Fine metodo remove

[Test #3] 	Inizio metodo multiplicity
[Test #3] 		Uso l'ultimo multiset utilizzato, controllo che per ogni elemento il metodo multiplicity restituisca il numero di occorrenze corretto:
[Test #3] 			Molteplicita' dell'elemento 5 aspettata 4, ho 4 OK!
[Test #3] 			Molteplicita' dell'elemento 2 aspettata 1, ho 1 OK!
[Test #3] 		Molteplicita' dell'elemento 0 non presente... Risultato: 0 OK!
[Test #3] 	Fine metodo multiplicity

[Test #3] 	Inizio operator==
[Test #3] 		A partire dall'ultimo multiset utilizzato creo un altro multiset ma con policy di ordinamento diversa:
[Test #3] 			Stampo il multiset che vado ad utilizzare:
[Test #3] 			{<5, 4>, <2, 1>} OK!
[Test #3] 			Creo un nuovo multiset con ordinamento diverso, utilizzando il costruttore che prende due iteratori... OK!
[Test #3] 		Nuovo multiset con ordinamento diverso creato, lo stampo qui sotto:
[Test #3] 		{<2, 1>, <5, 4>}
[Test #3] 		Utilizzo l'operator== tra i due multiset ordinati in modo diverso... Risultato: true OK!
[Test #3] 		Aggiungo l'elemento 0 al nuovo multiset e verifico che siano diversi... OK!
[Test #3] 		Stampo il nuovo multiset qui sotto:
[Test #3] 		{<2, 1>, <5, 4>, <0, 1>}
[Test #3] 		Svuoto quest'ultimo con la clear... OK!
[Test #3] 		Stampo il multiset... Risultato: {} OK!
[Test #3] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento uguale... Risultato: true OK!
[Test #3] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento diverso... Risultato: true OK!
[Test #3] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento uguale... Risultato: true OK!
[Test #3] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento diverso... Risultato: true OK!
[Test #3] 	Fine operator==

[Test #3] 	Inizio metodo contains
[Test #3] 		Creo un nuovo multiset con i seguenti valori: 2 3 1 5 2 2 6 -2 -5 -7 
[Test #3] 		Stampo il nuovo contenuto qui sotto:
[Test #3] 		{<1, 3>, <2, 5>, <3, 2>} OK!
[Test #3] 		Controllo che la contains dia true per ogni elemento distinto del multiset:
[Test #3] 			Contains dell'elemento 1... Risultato: true OK!
[Test #3] 			Contains dell'elemento 2... Risultato: true OK!
[Test #3] 			Contains dell'elemento 3... Risultato: true OK!
[Test #3] 		Controllo che la contains dia false per un elemento non contenuto:
[Test #3] 			Contains dell'elemento 0... Risultato: false OK!
[Test #3] 	Fine metodo contains

[Test #3] 	Inizio stampa con iteratori
[Test #3] 		Uso l'ultimo multiset utilizzato, stampo gli elementi in ordine del multiset ordinato tramite gli iteratori:
[Test #3] 		1 1 1 2 2 2 2 2 3 3  OK!
[Test #3] 		Ora di nuovo ma stampo partendo dalla fine, per utilizzare il decremento nell'iteratore bidirectional:
[Test #3] 		3 3 2 2 2 2 2 1 1 1  OK!
[Test #3] 		Controllo che gli elementi restituiti dall'iteratore costituiscono una permutazione degli elementi inseriti in precedenza... Risultato: true OK!
[Test #3] 		Stampo con gli iteratori un multiset vuoto:
[Test #3] 		 OK!
[Test #3] 	Fine stampa con iteratori

[Test #3] 	Fine interfaccia pubblica

[Test #3] 	Inizio const correctness
[Test #3] 	Metodi utilizzabili (da parte dell'utente o meno, come il distruttore) su un ordered_multiset costante:
[Test #3] 		Ctor di default... OK!
[Test #3] 		Costruttore che prende una coppia di iteratori... OK!
[Test #3] 		Distruttore... OK!
[Test #3] 		Copy constructor... OK!
[Test #3] 		Size... OK!
[Test #3] 		Multiplicity... OK!
[Test #3] 		Operatore di uguaglianza operator==... OK!
[Test #3] 		Contains... OK!
[Test #3] 		Begin... OK!
[Test #3] 		End... OK!
[Test #3] 		Operatore di stream operator<<... {<1, 3>, <2, 5>, <3, 2>} OK!
[Test #3] 	Fine metodi utilizzabili per multiset costanti

[Test #3] 	I metodi non utilizzabili dell'interfaccia pubblica per multiset costanti sono:
[Test #3] 	operator=, clear, swap, add, remove.
[Test #3] 	Fine const correctness

[Test #3] Fine test 3

[Test #4] Test 4: ordine decrescente in Z_4

[Test #4] 	Metodi fondamentali
[Test #4] 	Inizio costruttore di default
[Test #4] 		Controllo della size uguale a 0... Risultato: 0 OK!
[Test #4] 		Controllo che non sia contenuto nemmeno l'elemento 0... Risultato: true OK!
[Test #4] 		Controllo l'operator== con un altro multiset vuoto dello stesso tipo... Risultato: true OK!
[Test #4] 		Stampo il contenuto vuoto... Risultato: {} OK!
[Test #4] 	Fine costruttore di default

[Test #4] 	Inizio distruttore
[Test #4] 		Creazione oggetto allocato sullo heap e puntatore... OK!
[Test #4] 		Eseguo una delete... OK!
[Test #4] 	Fine distruttore

[Test #4] 	Inizio copy constructor
[Test #4] 		Inizialmente aggiungo qualche elemento al primo multiset creato col ctor di default:
[Test #4] 			Aggiungo l'elemento 2... OK!
[Test #4] 			Aggiungo l'elemento 1... OK!
[Test #4] 			Aggiungo l'elemento 2... OK!
[Test #4] 			Aggiungo l'elemento 6... OK!
[Test #4] 			Aggiungo l'elemento 5... OK!
[Test #4] 			Aggiungo l'elemento 2... OK!
[Test #4] 			Aggiungo l'elemento -2... OK!
[Test #4] 			Aggiungo l'elemento -6... OK!
[Test #4] 			Aggiungo l'elemento 9... OK!
[Test #4] 			Aggiungo l'elemento 8... OK!
[Test #4] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #4] 		Stampo il nuovo contenuto del multiset... Risultato: {<2, 6>, <1, 3>, <8, 1>} OK!
[Test #4] 		Ora creo una copia indipendente dei dati utilizzando il cctor... OK!
[Test #4] 		Stampo il multiset appena creato... Risultato: {<2, 6>, <1, 3>, <8, 1>} OK!
[Test #4] 		Controllo con l'operator== i due multiset... Risultato: true OK!
[Test #4] 		Chiamo la clear sul primo multiset e poi lo stampo... Risultato: {} OK!
[Test #4] 		Stampo il secondo multiset verificando l'indipendenza dei dati... Risultato: {<2, 6>, <1, 3>, <8, 1>} OK!
[Test #4] 	Fine copy constructor

[Test #4] 	Inizio operatore di assegnamento
[Test #4] 		Utilizzo l'operator= per assegnare al primo multiset un multiset vuoto creato al volo... OK!
[Test #4] 		Utilizzo l'operator= per assegnare al primo multiset i dati del secondo... OK!
[Test #4] 		Utilizzo l'operator= per assegnare al primo multiset se' stesso (auto-assegnamento)... OK!
[Test #4] 		Stampo il primo multiset... Risultato: {<2, 6>, <1, 3>, <8, 1>} OK!
[Test #4] 		Rimuovo l'unica occorrenza dell'elemento 396 dal secondo multiset per poi verificare l'indipendenza... OK!
[Test #4] 		Stampo il primo multiset... Risultato: {<2, 6>, <1, 3>, <8, 1>} OK!
[Test #4] 		Stampo il secondo multiset... Risultato: {<2, 6>, <1, 3>} OK!
[Test #4] 		Rimuovo un'occorrenza dell'elemento -2 dal primo multiset per poi verificare l'indipendenza... OK!
[Test #4] 		Stampo il primo multiset... Risultato: {<2, 5>, <1, 3>, <8, 1>} OK!
[Test #4] 		Stampo il secondo multiset... Risultato: {<2, 6>, <1, 3>} OK!
[Test #4] 	Fine operatore di assegnamento
[Test #4] 	Fine metodi fondamentali

[Test #4] 	Inizio test interfaccia pubblica
[Test #4] 	Inizio costruttore che prende una coppia di iteratori
[Test #4] 		Gli elementi che saranno aggiunti sono 2 2 5 -2 9 
[Test #4] 		Creazione multiset usando due iteratori... Risultato: {<2, 3>, <5, 2>} OK!
[Test #4] 		Creazione multiset usando due iteratori uguali, quindi che risultera' vuoto... Risultato: {} OK!
[Test #4] 	Fine costruttore che prende una coppia di iteratori

[Test #4] 	Inizio metodo clear
[Test #4] 		Utilizzo la clear su un multiset non vuoto, ossia quello costruito con due iteratori
[Test #4] 		Prima della clear: {<2, 3>, <5, 2>}
[Test #4] 		Dopo la clear: {} OK!
[Test #4] 		Utilizzo la clear su un multiset vuoto, ossia quello costruito con due iteratori uguali
[Test #4] 		Prima della clear: {}
[Test #4] 		Dopo la clear: {} OK!
[Test #4] 	Fine metodo clear

[Test #4] 	Inizio metodo swap
[Test #4] 		Riutilizzo due multiset creati in precedenza qui sotto stampati:
[Test #4] 		Primo multiset: {<2, 5>, <1, 3>, <8, 1>}
[Test #4] 		Secondo multiset: {<2, 6>, <1, 3>}
[Test #4] 		Chiamo la swap... OK!
[Test #4] 		Controllo che i due contenuti siano stati scambiati... OK!
[Test #4] 		Stampo i due multiset dopo la swap qui sotto:
[Test #4] 		Primo multiset: {<2, 6>, <1, 3>}
[Test #4] 		Secondo multiset: {<2, 5>, <1, 3>, <8, 1>}
[Test #4] 		Ora scambio il primo multiset con un multiset vuoto creato in precedenza... OK!
[Test #4] 		Stampo qui sotto i due multiset:
[Test #4] 		Multiset che era vuoto: {<2, 6>, <1, 3>}
[Test #4] 		Multiset che era riempito: {}
[Test #4] 		Li riporto allo stato originale con un'altra swap... OK!
[Test #4] 		Multiset di nuovo vuoto: {}
[Test #4] 		Multiset di nuovo riempito: {<2, 6>, <1, 3>}
[Test #4] 		Infine scambio due multiset vuoti tra di loro e li stampo... {} {} OK!
[Test #4] 	Fine metodo swap

[Test #4] 	Inizio metodo size
[Test #4] 		Chiamo la size su un multiset vuoto, mi aspetto 0... Risultato: 0 OK!
[Test #4] 		Chiamo la size sul multiset utilizzato in precedenza che stampo qui sotto:
[Test #4] 		Multiset: {<2, 6>, <1, 3>}
[Test #4] 		Mi aspetto 9... Risultato: 9 OK!
[Test #4] 		Aggiungo l'elemento 3 e verifico che la size venga incrementata, mi aspetto 10... Risultato: 10 OK!
[Test #4] 		Rimuovo l'elemento appena aggiunto e verifico che la size venga decrementata, mi aspetto 9... Risultato: 9 OK!
[Test #4] 	Fine metodo size

[Test #4] 	Inizio metodo add
[Test #4] 		Utilizzo un multiset vuoto: {}
[Test #4] 		Aggiungo 9 volte l'elemento 0... OK!
[Test #4] 		Verifico la correttezza del contenuto, mi aspetto {<0, 9>}... Risultato: {<0, 9>} OK!
[Test #4] 		Aggiungo altri elementi:
[Test #4] 			Aggiungo l'elemento 1... OK!
[Test #4] 			Aggiungo l'elemento 6... OK!
[Test #4] 			Aggiungo l'elemento 2... OK!
[Test #4] 			Aggiungo l'elemento -6... OK!
[Test #4] 			Aggiungo l'elemento 8... OK!
[Test #4] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #4] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #4] 		{<6, 3>, <1, 1>, <0, 10>} OK!
[Test #4] 	Fine metodo add

[Test #4] 	Inizio metodo remove
[Test #4] 		Utilizzo lo stesso multiset di prima, rimuovo 9 occorrenze di 0... OK!
[Test #4] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #4] 		{<6, 3>, <1, 1>, <0, 1>} OK!
[Test #4] 		Verifico che ci sia una sola occorrenza di 0... Risultato: true OK!
[Test #4] 		Elimino l'ultima occorrenza di 0... OK!
[Test #4] 		Stampo il nuovo contenuto qui sotto:
[Test #4] 		{<6, 3>, <1, 1>} OK!
[Test #4] 		(Mi aspetto l'eccezione custom) Provo ad eliminare l'elemento 3 non presente:
[Test #4] 		Eccezione custom catturata: Impossibile rimuovere un elemento non presente nel multiset ordinato.
[Test #4] 	Fine metodo remove

[Test #4] 	Inizio metodo multiplicity
[Test #4] 		Uso l'ultimo multiset utilizzato, controllo che per ogni elemento il metodo multiplicity restituisca il numero di occorrenze corretto:
[Test #4] 			Molteplicita' dell'elemento 6 aspettata 3, ho 3 OK!
[Test #4] 			Molteplicita' dell'elemento 1 aspettata 1, ho 1 OK!
[Test #4] 		Molteplicita' dell'elemento 0 non presente... Risultato: 0 OK!
[Test #4] 	Fine metodo multiplicity

[Test #4] 	Inizio operator==
[Test #4] 		A partire dall'ultimo multiset utilizzato creo un altro multiset ma con policy di ordinamento diversa:
[Test #4] 			Stampo il multiset che vado ad utilizzare:
[Test #4] 			{<6, 3>, <1, 1>} OK!
[Test #4] 			Creo un nuovo multiset con ordinamento diverso, utilizzando il costruttore che prende due iteratori... OK!
[Test #4] 		Nuovo multiset con ordinamento diverso creato, lo stampo qui sotto:
[Test #4] 		{<1, 1>, <6, 3>}
[Test #4] 		Utilizzo l'operator== tra i due multiset ordinati in modo diverso... Risultato: true OK!
[Test #4] 		Aggiungo l'elemento 0 al nuovo multiset e verifico che siano diversi... OK!
[Test #4] 		Stampo il nuovo multiset qui sotto:
[Test #4] 		{<0, 1>, <1, 1>, <6, 3>}
[Test #4] 		Svuoto quest'ultimo con la clear... OK!
[Test #4] 		Stampo il multiset... Risultato: {} OK!
[Test #4] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento uguale... Risultato: true OK!
[Test #4] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento diverso... Risultato: true OK!
[Test #4] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento uguale... Risultato: true OK!
[Test #4] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento diverso... Risultato: true OK!
[Test #4] 	Fine operator==

[Test #4] 	Inizio metodo contains
[Test #4] 		Creo un nuovo multiset con i seguenti valori: 8 2 9 4 -2 -6 -3 -6 -12 -42 30 
[Test #4] 		Stampo il nuovo contenuto qui sotto:
[Test #4] 		{<2, 6>, <9, 2>, <8, 3>} OK!
[Test #4] 		Controllo che la contains dia true per ogni elemento distinto del multiset:
[Test #4] 			Contains dell'elemento 2... Risultato: true OK!
[Test #4] 			Contains dell'elemento 9... Risultato: true OK!
[Test #4] 			Contains dell'elemento 8... Risultato: true OK!
[Test #4] 		Controllo che la contains dia false per un elemento non contenuto:
[Test #4] 			Contains dell'elemento 3... Risultato: false OK!
[Test #4] 	Fine metodo contains

[Test #4] 	Inizio stampa con iteratori
[Test #4] 		Uso l'ultimo multiset utilizzato, stampo gli elementi in ordine del multiset ordinato tramite gli iteratori:
[Test #4] 		2 2 2 2 2 2 9 9 8 8 8  OK!
[Test #4] 		Ora di nuovo ma stampo partendo dalla fine, per utilizzare il decremento nell'iteratore bidirectional:
[Test #4] 		8 8 8 9 9 2 2 2 2 2 2  OK!
[Test #4] 		Controllo che gli elementi restituiti dall'iteratore costituiscono una permutazione degli elementi inseriti in precedenza... Risultato: true OK!
[Test #4] 		Stampo con gli iteratori un multiset vuoto:
[Test #4] 		 OK!
[Test #4] 	Fine stampa con iteratori

[Test #4] 	Fine interfaccia pubblica

[Test #4] 	Inizio const correctness
[Test #4] 	Metodi utilizzabili (da parte dell'utente o meno, come il distruttore) su un ordered_multiset costante:
[Test #4] 		Ctor di default... OK!
[Test #4] 		Costruttore che prende una coppia di iteratori... OK!
[Test #4] 		Distruttore... OK!
[Test #4] 		Copy constructor... OK!
[Test #4] 		Size... OK!
[Test #4] 		Multiplicity... OK!
[Test #4] 		Operatore di uguaglianza operator==... OK!
[Test #4] 		Contains... OK!
[Test #4] 		Begin... OK!
[Test #4] 		End... OK!
[Test #4] 		Operatore di stream operator<<... {<2, 6>, <9, 2>, <8, 3>} OK!
[Test #4] 	Fine metodi utilizzabili per multiset costanti

[Test #4] 	I metodi non utilizzabili dell'interfaccia pubblica per multiset costanti sono:
[Test #4] 	operator=, clear, swap, add, remove.
[Test #4] 	Fine const correctness

[Test #4] Fine test 4

[Test #5] Test 5: ordine crescente per valore assoluto

[Test #5] 	Metodi fondamentali
[Test #5] 	Inizio costruttore di default
[Test #5] 		Controllo della size uguale a 0... Risultato: 0 OK!
[Test #5] 		Controllo che non sia contenuto nemmeno l'elemento 0... Risultato: true OK!
[Test #5] 		Controllo l'operator== con un altro multiset vuoto dello stesso tipo... Risultato: true OK!
[Test #5] 		Stampo il contenuto vuoto... Risultato: {} OK!
[Test #5] 	Fine costruttore di default

[Test #5] 	Inizio distruttore
[Test #5] 		Creazione oggetto allocato sullo heap e puntatore... OK!
[Test #5] 		Eseguo una delete... OK!
[Test #5] 	Fine distruttore

[Test #5] 	Inizio copy constructor
[Test #5] 		Inizialmente aggiungo qualche elemento al primo multiset creato col ctor di default:
[Test #5] 			Aggiungo l'elemento 0... OK!
[Test #5] 			Aggiungo l'elemento 0... OK!
[Test #5] 			Aggiungo l'elemento -1... OK!
[Test #5] 			Aggiungo l'elemento 1... OK!
[Test #5] 			Aggiungo l'elemento 24... OK!
[Test #5] 			Aggiungo l'elemento 42... OK!
[Test #5] 			Aggiungo l'elemento -24... OK!
[Test #5] 			Aggiungo l'elemento 49... OK!
[Test #5] 			Aggiungo l'elemento 49... OK!
[Test #5] 			Aggiungo l'elemento -50... OK!
[Test #5] 			Aggiungo l'elemento 29... OK!
[Test #5] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #5] 		Stampo il nuovo contenuto del multiset... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 		Ora creo una copia indipendente dei dati utilizzando il cctor... OK!
[Test #5] 		Stampo il multiset appena creato... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 		Controllo con l'operator== i due multiset... Risultato: true OK!
[Test #5] 		Chiamo la clear sul primo multiset e poi lo stampo... Risultato: {} OK!
[Test #5] 		Stampo il secondo multiset verificando l'indipendenza dei dati... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 	Fine copy constructor

[Test #5] 	Inizio operatore di assegnamento
[Test #5] 		Utilizzo l'operator= per assegnare al primo multiset un multiset vuoto creato al volo... OK!
[Test #5] 		Utilizzo l'operator= per assegnare al primo multiset i dati del secondo... OK!
[Test #5] 		Utilizzo l'operator= per assegnare al primo multiset se' stesso (auto-assegnamento)... OK!
[Test #5] 		Stampo il primo multiset... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 		Rimuovo l'unica occorrenza dell'elemento -29 dal secondo multiset per poi verificare l'indipendenza... OK!
[Test #5] 		Stampo il primo multiset... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 		Stampo il secondo multiset... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 		Rimuovo un'occorrenza dell'elemento 49 dal primo multiset per poi verificare l'indipendenza... OK!
[Test #5] 		Stampo il primo multiset... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 1>, <-50, 1>} OK!
[Test #5] 		Stampo il secondo multiset... Risultato: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>} OK!
[Test #5] 	Fine operatore di assegnamento
[Test #5] 	Fine metodi fondamentali

[Test #5] 	Inizio test interfaccia pubblica
[Test #5] 	Inizio costruttore che prende una coppia di iteratori
[Test #5] 		Gli elementi che saranno aggiunti sono 0 -1 24 -24 49 29 
[Test #5] 		Creazione multiset usando due iteratori... Risultato: {<0, 1>, <-1, 1>, <24, 2>, <29, 1>, <49, 1>} OK!
[Test #5] 		Creazione multiset usando due iteratori uguali, quindi che risultera' vuoto... Risultato: {} OK!
[Test #5] 	Fine costruttore che prende una coppia di iteratori

[Test #5] 	Inizio metodo clear
[Test #5] 		Utilizzo la clear su un multiset non vuoto, ossia quello costruito con due iteratori
[Test #5] 		Prima della clear: {<0, 1>, <-1, 1>, <24, 2>, <29, 1>, <49, 1>}
[Test #5] 		Dopo la clear: {} OK!
[Test #5] 		Utilizzo la clear su un multiset vuoto, ossia quello costruito con due iteratori uguali
[Test #5] 		Prima della clear: {}
[Test #5] 		Dopo la clear: {} OK!
[Test #5] 	Fine metodo clear

[Test #5] 	Inizio metodo swap
[Test #5] 		Riutilizzo due multiset creati in precedenza qui sotto stampati:
[Test #5] 		Primo multiset: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 1>, <-50, 1>}
[Test #5] 		Secondo multiset: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>}
[Test #5] 		Chiamo la swap... OK!
[Test #5] 		Controllo che i due contenuti siano stati scambiati... OK!
[Test #5] 		Stampo i due multiset dopo la swap qui sotto:
[Test #5] 		Primo multiset: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>}
[Test #5] 		Secondo multiset: {<0, 2>, <-1, 2>, <24, 2>, <29, 1>, <42, 1>, <49, 1>, <-50, 1>}
[Test #5] 		Ora scambio il primo multiset con un multiset vuoto creato in precedenza... OK!
[Test #5] 		Stampo qui sotto i due multiset:
[Test #5] 		Multiset che era vuoto: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>}
[Test #5] 		Multiset che era riempito: {}
[Test #5] 		Li riporto allo stato originale con un'altra swap... OK!
[Test #5] 		Multiset di nuovo vuoto: {}
[Test #5] 		Multiset di nuovo riempito: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>}
[Test #5] 		Infine scambio due multiset vuoti tra di loro e li stampo... {} {} OK!
[Test #5] 	Fine metodo swap

[Test #5] 	Inizio metodo size
[Test #5] 		Chiamo la size su un multiset vuoto, mi aspetto 0... Risultato: 0 OK!
[Test #5] 		Chiamo la size sul multiset utilizzato in precedenza che stampo qui sotto:
[Test #5] 		Multiset: {<0, 2>, <-1, 2>, <24, 2>, <42, 1>, <49, 2>, <-50, 1>}
[Test #5] 		Mi aspetto 10... Risultato: 10 OK!
[Test #5] 		Aggiungo l'elemento 100 e verifico che la size venga incrementata, mi aspetto 11... Risultato: 11 OK!
[Test #5] 		Rimuovo l'elemento appena aggiunto e verifico che la size venga decrementata, mi aspetto 10... Risultato: 10 OK!
[Test #5] 	Fine metodo size

[Test #5] 	Inizio metodo add
[Test #5] 		Utilizzo un multiset vuoto: {}
[Test #5] 		Aggiungo 4 volte l'elemento 0... OK!
[Test #5] 		Verifico la correttezza del contenuto, mi aspetto {<0, 4>}... Risultato: {<0, 4>} OK!
[Test #5] 		Aggiungo altri elementi:
[Test #5] 			Aggiungo l'elemento 0... OK!
[Test #5] 			Aggiungo l'elemento 1... OK!
[Test #5] 			Aggiungo l'elemento 42... OK!
[Test #5] 			Aggiungo l'elemento 49... OK!
[Test #5] 			Aggiungo l'elemento -50... OK!
[Test #5] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #5] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #5] 		{<0, 5>, <1, 1>, <42, 1>, <49, 1>, <-50, 1>} OK!
[Test #5] 	Fine metodo add

[Test #5] 	Inizio metodo remove
[Test #5] 		Utilizzo lo stesso multiset di prima, rimuovo 4 occorrenze di 0... OK!
[Test #5] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #5] 		{<0, 1>, <1, 1>, <42, 1>, <49, 1>, <-50, 1>} OK!
[Test #5] 		Verifico che ci sia una sola occorrenza di 0... Risultato: true OK!
[Test #5] 		Elimino l'ultima occorrenza di 0... OK!
[Test #5] 		Stampo il nuovo contenuto qui sotto:
[Test #5] 		{<1, 1>, <42, 1>, <49, 1>, <-50, 1>} OK!
[Test #5] 		(Mi aspetto l'eccezione custom) Provo ad eliminare l'elemento 100 non presente:
[Test #5] 		Eccezione custom catturata: Impossibile rimuovere un elemento non presente nel multiset ordinato.
[Test #5] 	Fine metodo remove

[Test #5] 	Inizio metodo multiplicity
[Test #5] 		Uso l'ultimo multiset utilizzato, controllo che per ogni elemento il metodo multiplicity restituisca il numero di occorrenze corretto:
[Test #5] 			Molteplicita' dell'elemento 1 aspettata 1, ho 1 OK!
[Test #5] 			Molteplicita' dell'elemento 42 aspettata 1, ho 1 OK!
[Test #5] 			Molteplicita' dell'elemento 49 aspettata 1, ho 1 OK!
[Test #5] 			Molteplicita' dell'elemento -50 aspettata 1, ho 1 OK!
[Test #5] 		Molteplicita' dell'elemento 0 non presente... Risultato: 0 OK!
[Test #5] 	Fine metodo multiplicity

[Test #5] 	Inizio operator==
[Test #5] 		A partire dall'ultimo multiset utilizzato creo un altro multiset ma con policy di ordinamento diversa:
[Test #5] 			Stampo il multiset che vado ad utilizzare:
[Test #5] 			{<1, 1>, <42, 1>, <49, 1>, <-50, 1>} OK!
[Test #5] 			Creo un nuovo multiset con ordinamento diverso, utilizzando il costruttore che prende due iteratori... OK!
[Test #5] 		Nuovo multiset con ordinamento diverso creato, lo stampo qui sotto:
[Test #5] 		{<-50, 1>, <49, 1>, <42, 1>, <1, 1>}
[Test #5] 		Utilizzo l'operator== tra i due multiset ordinati in modo diverso... Risultato: true OK!
[Test #5] 		Aggiungo l'elemento 0 al nuovo multiset e verifico che siano diversi... OK!
[Test #5] 		Stampo il nuovo multiset qui sotto:
[Test #5] 		{<-50, 1>, <49, 1>, <42, 1>, <1, 1>, <0, 1>}
[Test #5] 		Svuoto quest'ultimo con la clear... OK!
[Test #5] 		Stampo il multiset... Risultato: {} OK!
[Test #5] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento uguale... Risultato: true OK!
[Test #5] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento diverso... Risultato: true OK!
[Test #5] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento uguale... Risultato: true OK!
[Test #5] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento diverso... Risultato: true OK!
[Test #5] 	Fine operator==

[Test #5] 	Inizio metodo contains
[Test #5] 		Creo un nuovo multiset con i seguenti valori: 3 2 4 3 -3 -3 -2 9 -9 1 
[Test #5] 		Stampo il nuovo contenuto qui sotto:
[Test #5] 		{<1, 1>, <2, 2>, <3, 4>, <4, 1>, <9, 2>} OK!
[Test #5] 		Controllo che la contains dia true per ogni elemento distinto del multiset:
[Test #5] 			Contains dell'elemento 1... Risultato: true OK!
[Test #5] 			Contains dell'elemento 2... Risultato: true OK!
[Test #5] 			Contains dell'elemento 3... Risultato: true OK!
[Test #5] 			Contains dell'elemento 4... Risultato: true OK!
[Test #5] 			Contains dell'elemento 9... Risultato: true OK!
[Test #5] 		Controllo che la contains dia false per un elemento non contenuto:
[Test #5] 			Contains dell'elemento 100... Risultato: false OK!
[Test #5] 	Fine metodo contains

[Test #5] 	Inizio stampa con iteratori
[Test #5] 		Uso l'ultimo multiset utilizzato, stampo gli elementi in ordine del multiset ordinato tramite gli iteratori:
[Test #5] 		1 2 2 3 3 3 3 4 9 9  OK!
[Test #5] 		Ora di nuovo ma stampo partendo dalla fine, per utilizzare il decremento nell'iteratore bidirectional:
[Test #5] 		9 9 4 3 3 3 3 2 2 1  OK!
[Test #5] 		Controllo che gli elementi restituiti dall'iteratore costituiscono una permutazione degli elementi inseriti in precedenza... Risultato: true OK!
[Test #5] 		Stampo con gli iteratori un multiset vuoto:
[Test #5] 		 OK!
[Test #5] 	Fine stampa con iteratori

[Test #5] 	Fine interfaccia pubblica

[Test #5] 	Inizio const correctness
[Test #5] 	Metodi utilizzabili (da parte dell'utente o meno, come il distruttore) su un ordered_multiset costante:
[Test #5] 		Ctor di default... OK!
[Test #5] 		Costruttore che prende una coppia di iteratori... OK!
[Test #5] 		Distruttore... OK!
[Test #5] 		Copy constructor... OK!
[Test #5] 		Size... OK!
[Test #5] 		Multiplicity... OK!
[Test #5] 		Operatore di uguaglianza operator==... OK!
[Test #5] 		Contains... OK!
[Test #5] 		Begin... OK!
[Test #5] 		End... OK!
[Test #5] 		Operatore di stream operator<<... {<1, 1>, <2, 2>, <3, 4>, <4, 1>, <9, 2>} OK!
[Test #5] 	Fine metodi utilizzabili per multiset costanti

[Test #5] 	I metodi non utilizzabili dell'interfaccia pubblica per multiset costanti sono:
[Test #5] 	operator=, clear, swap, add, remove.
[Test #5] 	Fine const correctness

[Test #5] Fine test 5

[Test #6] Test 6: ordine decrescente per valore assoluto

[Test #6] 	Metodi fondamentali
[Test #6] 	Inizio costruttore di default
[Test #6] 		Controllo della size uguale a 0... Risultato: 0 OK!
[Test #6] 		Controllo che non sia contenuto nemmeno l'elemento 0... Risultato: true OK!
[Test #6] 		Controllo l'operator== con un altro multiset vuoto dello stesso tipo... Risultato: true OK!
[Test #6] 		Stampo il contenuto vuoto... Risultato: {} OK!
[Test #6] 	Fine costruttore di default

[Test #6] 	Inizio distruttore
[Test #6] 		Creazione oggetto allocato sullo heap e puntatore... OK!
[Test #6] 		Eseguo una delete... OK!
[Test #6] 	Fine distruttore

[Test #6] 	Inizio copy constructor
[Test #6] 		Inizialmente aggiungo qualche elemento al primo multiset creato col ctor di default:
[Test #6] 			Aggiungo l'elemento 39... OK!
[Test #6] 			Aggiungo l'elemento 90... OK!
[Test #6] 			Aggiungo l'elemento -20... OK!
[Test #6] 			Aggiungo l'elemento 27... OK!
[Test #6] 			Aggiungo l'elemento 48... OK!
[Test #6] 			Aggiungo l'elemento -5... OK!
[Test #6] 			Aggiungo l'elemento 3... OK!
[Test #6] 			Aggiungo l'elemento 9... OK!
[Test #6] 			Aggiungo l'elemento 20... OK!
[Test #6] 			Aggiungo l'elemento -45... OK!
[Test #6] 			Aggiungo l'elemento 90... OK!
[Test #6] 			Aggiungo l'elemento 150... OK!
[Test #6] 			Aggiungo l'elemento 1... OK!
[Test #6] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #6] 		Stampo il nuovo contenuto del multiset... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 		Ora creo una copia indipendente dei dati utilizzando il cctor... OK!
[Test #6] 		Stampo il multiset appena creato... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 		Controllo con l'operator== i due multiset... Risultato: true OK!
[Test #6] 		Chiamo la clear sul primo multiset e poi lo stampo... Risultato: {} OK!
[Test #6] 		Stampo il secondo multiset verificando l'indipendenza dei dati... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 	Fine copy constructor

[Test #6] 	Inizio operatore di assegnamento
[Test #6] 		Utilizzo l'operator= per assegnare al primo multiset un multiset vuoto creato al volo... OK!
[Test #6] 		Utilizzo l'operator= per assegnare al primo multiset i dati del secondo... OK!
[Test #6] 		Utilizzo l'operator= per assegnare al primo multiset se' stesso (auto-assegnamento)... OK!
[Test #6] 		Stampo il primo multiset... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 		Rimuovo l'unica occorrenza dell'elemento 5 dal secondo multiset per poi verificare l'indipendenza... OK!
[Test #6] 		Stampo il primo multiset... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 		Stampo il secondo multiset... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 		Rimuovo un'occorrenza dell'elemento -90 dal primo multiset per poi verificare l'indipendenza... OK!
[Test #6] 		Stampo il primo multiset... Risultato: {<150, 1>, <90, 1>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 		Stampo il secondo multiset... Risultato: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>} OK!
[Test #6] 	Fine operatore di assegnamento
[Test #6] 	Fine metodi fondamentali

[Test #6] 	Inizio test interfaccia pubblica
[Test #6] 	Inizio costruttore che prende una coppia di iteratori
[Test #6] 		Gli elementi che saranno aggiunti sono 39 -20 48 3 20 90 1 
[Test #6] 		Creazione multiset usando due iteratori... Risultato: {<90, 1>, <48, 1>, <39, 1>, <-20, 2>, <3, 1>, <1, 1>} OK!
[Test #6] 		Creazione multiset usando due iteratori uguali, quindi che risultera' vuoto... Risultato: {} OK!
[Test #6] 	Fine costruttore che prende una coppia di iteratori

[Test #6] 	Inizio metodo clear
[Test #6] 		Utilizzo la clear su un multiset non vuoto, ossia quello costruito con due iteratori
[Test #6] 		Prima della clear: {<90, 1>, <48, 1>, <39, 1>, <-20, 2>, <3, 1>, <1, 1>}
[Test #6] 		Dopo la clear: {} OK!
[Test #6] 		Utilizzo la clear su un multiset vuoto, ossia quello costruito con due iteratori uguali
[Test #6] 		Prima della clear: {}
[Test #6] 		Dopo la clear: {} OK!
[Test #6] 	Fine metodo clear

[Test #6] 	Inizio metodo swap
[Test #6] 		Riutilizzo due multiset creati in precedenza qui sotto stampati:
[Test #6] 		Primo multiset: {<150, 1>, <90, 1>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>}
[Test #6] 		Secondo multiset: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>}
[Test #6] 		Chiamo la swap... OK!
[Test #6] 		Controllo che i due contenuti siano stati scambiati... OK!
[Test #6] 		Stampo i due multiset dopo la swap qui sotto:
[Test #6] 		Primo multiset: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>}
[Test #6] 		Secondo multiset: {<150, 1>, <90, 1>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <-5, 1>, <3, 1>, <1, 1>}
[Test #6] 		Ora scambio il primo multiset con un multiset vuoto creato in precedenza... OK!
[Test #6] 		Stampo qui sotto i due multiset:
[Test #6] 		Multiset che era vuoto: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>}
[Test #6] 		Multiset che era riempito: {}
[Test #6] 		Li riporto allo stato originale con un'altra swap... OK!
[Test #6] 		Multiset di nuovo vuoto: {}
[Test #6] 		Multiset di nuovo riempito: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>}
[Test #6] 		Infine scambio due multiset vuoti tra di loro e li stampo... {} {} OK!
[Test #6] 	Fine metodo swap

[Test #6] 	Inizio metodo size
[Test #6] 		Chiamo la size su un multiset vuoto, mi aspetto 0... Risultato: 0 OK!
[Test #6] 		Chiamo la size sul multiset utilizzato in precedenza che stampo qui sotto:
[Test #6] 		Multiset: {<150, 1>, <90, 2>, <48, 1>, <-45, 1>, <39, 1>, <27, 1>, <-20, 2>, <9, 1>, <3, 1>, <1, 1>}
[Test #6] 		Mi aspetto 12... Risultato: 12 OK!
[Test #6] 		Aggiungo l'elemento -2 e verifico che la size venga incrementata, mi aspetto 13... Risultato: 13 OK!
[Test #6] 		Rimuovo l'elemento appena aggiunto e verifico che la size venga decrementata, mi aspetto 12... Risultato: 12 OK!
[Test #6] 	Fine metodo size

[Test #6] 	Inizio metodo add
[Test #6] 		Utilizzo un multiset vuoto: {}
[Test #6] 		Aggiungo 7 volte l'elemento 0... OK!
[Test #6] 		Verifico la correttezza del contenuto, mi aspetto {<0, 7>}... Risultato: {<0, 7>} OK!
[Test #6] 		Aggiungo altri elementi:
[Test #6] 			Aggiungo l'elemento 90... OK!
[Test #6] 			Aggiungo l'elemento 27... OK!
[Test #6] 			Aggiungo l'elemento -5... OK!
[Test #6] 			Aggiungo l'elemento 9... OK!
[Test #6] 			Aggiungo l'elemento -45... OK!
[Test #6] 			Aggiungo l'elemento 150... OK!
[Test #6] 		Controllo che gli elementi siano stati inseriti nell'ordine corretto... Risultato: true OK!
[Test #6] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #6] 		{<150, 1>, <90, 1>, <-45, 1>, <27, 1>, <9, 1>, <-5, 1>, <0, 7>} OK!
[Test #6] 	Fine metodo add

[Test #6] 	Inizio metodo remove
[Test #6] 		Utilizzo lo stesso multiset di prima, rimuovo 6 occorrenze di 0... OK!
[Test #6] 		Stampo il nuovo contenuto del multiset qui sotto:
[Test #6] 		{<150, 1>, <90, 1>, <-45, 1>, <27, 1>, <9, 1>, <-5, 1>, <0, 1>} OK!
[Test #6] 		Verifico che ci sia una sola occorrenza di 0... Risultato: true OK!
[Test #6] 		Elimino l'ultima occorrenza di 0... OK!
[Test #6] 		Stampo il nuovo contenuto qui sotto:
[Test #6] 		{<150, 1>, <90, 1>, <-45, 1>, <27, 1>, <9, 1>, <-5, 1>} OK!
[Test #6] 		(Mi aspetto l'eccezione custom) Provo ad eliminare l'elemento -2 non presente:
[Test #6] 		Eccezione custom catturata: Impossibile rimuovere un elemento non presente nel multiset ordinato.
[Test #6] 	Fine metodo remove

[Test #6] 	Inizio metodo multiplicity
[Test #6] 		Uso l'ultimo multiset utilizzato, controllo che per ogni elemento il metodo multiplicity restituisca il numero di occorrenze corretto:
[Test #6] 			Molteplicita' dell'elemento 150 aspettata 1, ho 1 OK!
[Test #6] 			Molteplicita' dell'elemento 90 aspettata 1, ho 1 OK!
[Test #6] 			Molteplicita' dell'elemento -45 aspettata 1, ho 1 OK!
[Test #6] 			Molteplicita' dell'elemento 27 aspettata 1, ho 1 OK!
[Test #6] 			Molteplicita' dell'elemento 9 aspettata 1, ho 1 OK!
[Test #6] 			Molteplicita' dell'elemento -5 aspettata 1, ho 1 OK!
[Test #6] 		Molteplicita' dell'elemento 0 non presente... Risultato: 0 OK!
[Test #6] 	Fine metodo multiplicity

[Test #6] 	Inizio operator==
[Test #6] 		A partire dall'ultimo multiset utilizzato creo un altro multiset ma con policy di ordinamento diversa:
[Test #6] 			Stampo il multiset che vado ad utilizzare:
[Test #6] 			{<150, 1>, <90, 1>, <-45, 1>, <27, 1>, <9, 1>, <-5, 1>} OK!
[Test #6] 			Creo un nuovo multiset con ordinamento diverso, utilizzando il costruttore che prende due iteratori... OK!
[Test #6] 		Nuovo multiset con ordinamento diverso creato, lo stampo qui sotto:
[Test #6] 		{<-5, 1>, <9, 1>, <27, 1>, <-45, 1>, <90, 1>, <150, 1>}
[Test #6] 		Utilizzo l'operator== tra i due multiset ordinati in modo diverso... Risultato: true OK!
[Test #6] 		Aggiungo l'elemento 0 al nuovo multiset e verifico che siano diversi... OK!
[Test #6] 		Stampo il nuovo multiset qui sotto:
[Test #6] 		{<0, 1>, <-5, 1>, <9, 1>, <27, 1>, <-45, 1>, <90, 1>, <150, 1>}
[Test #6] 		Svuoto quest'ultimo con la clear... OK!
[Test #6] 		Stampo il multiset... Risultato: {} OK!
[Test #6] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento uguale... Risultato: true OK!
[Test #6] 		Verifico l'uguaglianza con un multiset vuoto di ordinamento diverso... Risultato: true OK!
[Test #6] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento uguale... Risultato: true OK!
[Test #6] 		Verifico l'uguaglianza tra due multiset vuoti di ordinamento diverso... Risultato: true OK!
[Test #6] 	Fine operator==

[Test #6] 	Inizio metodo contains
[Test #6] 		Creo un nuovo multiset con i seguenti valori: -19 -29 50 -25 90 1 -7 
[Test #6] 		Stampo il nuovo contenuto qui sotto:
[Test #6] 		{<90, 1>, <50, 1>, <-29, 1>, <-25, 1>, <-19, 1>, <-7, 1>, <1, 1>} OK!
[Test #6] 		Controllo che la contains dia true per ogni elemento distinto del multiset:
[Test #6] 			Contains dell'elemento 90... Risultato: true OK!
[Test #6] 			Contains dell'elemento 50... Risultato: true OK!
[Test #6] 			Contains dell'elemento -29... Risultato: true OK!
[Test #6] 			Contains dell'elemento -25... Risultato: true OK!
[Test #6] 			Contains dell'elemento -19... Risultato: true OK!
[Test #6] 			Contains dell'elemento -7... Risultato: true OK!
[Test #6] 			Contains dell'elemento 1... Risultato: true OK!
[Test #6] 		Controllo che la contains dia false per un elemento non contenuto:
[Test #6] 			Contains dell'elemento -2... Risultato: false OK!
[Test #6] 	Fine metodo contains

[Test #6] 	Inizio stampa con iteratori
[Test #6] 		Uso l'ultimo multiset utilizzato, stampo gli elementi in ordine del multiset ordinato tramite gli iteratori:
[Test #6] 		90 50 -29 -25 -19 -7 1  OK!
[Test #6] 		Ora di nuovo ma stampo partendo dalla fine, per utilizzare il decremento nell'iteratore bidirectional:
[Test #6] 		1 -7 -19 -25 -29 50 90  OK!
[Test #6] 		Controllo che gli elementi restituiti dall'iteratore costituiscono una permutazione degli elementi inseriti in precedenza... Risultato: true OK!
[Test #6] 		Stampo con gli iteratori un multiset vuoto:
[Test #6] 		 OK!
[Test #6] 	Fine stampa con iteratori

[Test #6] 	Fine interfaccia pubblica

[Test #6] 	Inizio const correctness
[Test #6] 	Metodi utilizzabili (da parte dell'utente o meno, come il distruttore) su un ordered_multiset costante:
[Test #6] 		Ctor di default... OK!
[Test #6] 		Costruttore che prende una coppia di iteratori... OK!
[Test #6] 		Distruttore... OK!
[Test #6] 		Copy constructor... OK!
[Test #6] 		Size... OK!
[Test #6] 		Multiplicity... OK!
[Test #6] 		Operatore di uguaglianza operator==... OK!
[Test #6] 		Contains... OK!
[Test #6] 		Begin... OK!
[Test #6] 		End... OK!
[Test #6] 		Operatore di stream operator<<... {<90, 1>, <50, 1>, <-29, 1>, <-25, 1>, <-19, 1>, <-7, 1>, <1, 1>} OK!
[Test #6] 	Fine metodi utilizzabili per multiset costanti

[Test #6] 	I metodi non utilizzabili dell'interfaccia pubblica per multiset costanti sono:
[Test #6] 	operator=, clear, swap, add, remove.
[Test #6] 	Fine const correctness

[Test #6] Fine test 6

[Test #6] Fine unit test per il tipo int

